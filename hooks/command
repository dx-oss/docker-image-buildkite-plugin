#!/bin/bash

# https://buildkite.com/docs/pipelines/writing-build-scripts
# https://buildkite.com/docs/pipelines/writing-build-scripts#configuring-bash
set -eo pipefail

# common
aws --version

pwd=$(pwd)
dryrun=${BUILDKITE_PLUGIN_DOCKER_IMAGE_DRY:-0}
nocache=${BUILDKITE_PLUGIN_DOCKER_IMAGE_NOCACHE:-1}
ssh=${BUILDKITE_PLUGIN_DOCKER_IMAGE_SSH:-0}
ssh_file=${BUILDKITE_PLUGIN_DOCKER_IMAGE_SSH_FILE:-"~/.ssh/id_rsa"}
github=${BUILDKITE_PLUGIN_DOCKER_IMAGE_GITHUB:-0}
nuget=${BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET:-0}

buildkite_agent=${BUILDKITE_PLUGIN_DOCKER_IMAGE_AGENT:-buildkite-agent}
docker=${BUILDKITE_PLUGIN_DOCKER_IMAGE_DOCKER:-docker}
debug=${BUILDKITE_PLUGIN_DOCKER_IMAGE_DEBUG:-0}
if [ $debug -gt 0 ]; then
    set -eox pipefail

    if [ $debug -eq 2 ]; then
        env
    fi

    $docker version
    $docker ps
    whoami
    pwd
fi

# version
version_meta=`$buildkite_agent meta-data get version || true`
version=${BUILDKITE_PLUGIN_DOCKER_IMAGE_VERSION:-$version_meta}
version=${version:-$BUILDKITE_TAG}
version=${version:-""}

# git
git_owner=$(echo "$BUILDKITE_REPO" | cut -d: -f 2 | cut -d/ -f 1)
git_repo=$(echo "$BUILDKITE_REPO" | cut -d: -f 2 | cut -d/ -f 2 | cut -d. -f 1)
git_url=https://github.com/${git_owner}/${git_repo}/

# image
name=${BUILDKITE_PLUGIN_DOCKER_IMAGE_NAME:-$git_repo}
namespace=${BUILDKITE_PLUGIN_DOCKER_IMAGE_NAMESPACE:-$git_owner}
image=${BUILDKITE_PLUGIN_DOCKER_IMAGE_IMAGE:-""}

# tags
tag_sha=$(git rev-parse --short $BUILDKITE_COMMIT)
#tag=${BUILDKITE_BUILD_ID:-$tag_sha}

tags=${BUILDKITE_PLUGIN_DOCKER_IMAGE_TAGS:-""}
if [ -z "$tags" ]; then
    for t in {0..10}
    do
        tag_name="BUILDKITE_PLUGIN_DOCKER_IMAGE_TAGS_$t"
        tag=${!tag_name:-""}

        if [ "$tag" == "" ]; then
            break
        elif [ "$tag" == "VERSION" ] && [ "$version" == "" ]; then
            echo "A tag with VERSION cannot be set when the version variable is empty"
            exit 1
        elif [ "$tag" == "SHA" ] && [ "$tag_sha" == "" ]; then
            echo "A tag with SHA cannot be set when the tag_sha variable is empty"
            exit 1
        fi

        tag=$(echo "$tag" | sed "s/SHA/${tag_sha}/gi" | sed "s/VERSION/${version}/gi")
        if [ "$tag" != "" ]; then
            tags="${tags} ${tag}"
        fi
    done

    if [ "${tags}" == "" ] && [ "${version}" != "" ]; then
        tags="${version}"
    fi
fi
if [ -z "$tags" ]; then
    echo "Tags are required"
    exit 1    
fi

# Dockerfile
wrkdir=${BUILDKITE_PLUGIN_DOCKER_IMAGE_WRKDIR:-$pwd}
file=${BUILDKITE_PLUGIN_DOCKER_IMAGE_FILE:-"Dockerfile"}
if [ ! -d "$wrkdir" ]; then
    echo "Working directory ($wrkdir) does not exists"
    exit 1
fi
cd $wrkdir
if [ ! -e "$file" ]; then
    echo "Dockerfile ($file) does not exists"
    exit 1
fi

# docker - check if a key is set and it exists in env, if not use default env
docker_file=$file
docker_assume_role_required=0
docker_role=${BUILDKITE_PLUGIN_DOCKER_IMAGE_ROLE:-""}
docker_registry=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_REGISTRY}
docker_registry_name=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_REGISTRY_NAME}
docker_registry_region=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_REGISTRY_REGION}
docker_registry_account=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_REGISTRY_ACCOUNT}
docker_auth_user=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_AUTH_USER}
docker_auth_secret=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_AUTH_SECRET}
docker_provider=${BUILDKITE_PLUGIN_DOCKER_IMAGE_PROVIDER:-$DOCKER_PROVIDER}
if [ "$docker_provider" = "ecr" ] || [ "$docker_provider" = "aws" ]; then
    aws --version

    aws_cli_v1=$(aws --version | grep -c "aws-cli/1")
    if [ $aws_cli_v1 -gt 0 ]; then
        echo "TODO: REMOVE THIS WHEN WE HAVE THE AWS VERSION IN AGENT(!)"
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        sudo ./aws/install
        /usr/local/bin/aws --version
    fi

    docker_registry=${AWS_ECR_REGISTRY:-$docker_registry}
    docker_registry_name=${docker_registry_name:-$BUILDKITE_PIPELINE_SLUG}
    docker_registry_name=${AWS_ECR_REGISTRY_NAME:-$docker_registry_name}

    docker_auth_user=${AWS_ECR_AUTH_USER:-$AWS_ACCESS_KEY_ID}
    docker_auth_secret=${AWS_ECR_AUTH_SECRET:-$AWS_SECRET_ACCESS_KEY}
    docker_role=${AWS_ECR_AUTH_ROLE}
    docker_registry_region=${docker_registry_region:-$AWS_DEFAULT_REGION}
    #docker_assume_role_required=1
    
    image=${image:="${namespace}/${name}"}

    export AWS_ACCESS_KEY_ID=${docker_auth_user}
    export AWS_SECRET_ACCESS_KEY=${docker_auth_secret}
    export AWS_DEFAULT_REGION=${docker_registry_region}

    # check ecr
    if [ "$docker_registry" == "" ]; then
        docker_registry=$(aws ecr describe-repositories --repository-names "${docker_registry_name}" --output text --query 'repositories[0].repositoryUri' || true)
        if [ "$docker_registry" == "" ]; then
            echo "Create registry ${docker_registry_name}"
            aws ecr create-repository --repository-name "${docker_registry_name}"
            docker_registry=$(aws ecr describe-repositories --repository-names "${docker_registry_name}" --output text --query 'repositories[0].repositoryUri' || true)            
        fi
        if [ "$docker_registry" == "" ]; then
            $docker_registry="${docker_registry_account}.dkr.ecr.${docker_registry_region}.amazonaws.com"
        fi
    fi

    echo "Login [${docker_registry}]"
    aws ecr get-login-password --region ${docker_registry_region} | docker login --username AWS --password-stdin ${docker_registry}
elif [ "$docker_provider" = "jfrog" ]; then
    docker_registry=${JFROG_DOCKER_REGISTRY}
    docker_auth_user=${JFROG_DOCKER_USER}
    docker_auth_secret=${JFROG_DOCKER_SECRET}
    image=${image:="${namespace}/${name}"}
elif [ "$docker_provider" = "github" ]; then
    docker_registry=${GITHUB_PACKAGE_DOCKER_REGISTRY}
    docker_auth_user=${GITHUB_PACKAGE_DOCKER_USER}
    docker_auth_secret=${GITHUB_PACKAGE_DOCKER_SECRET}    
    image=${image:="${git_owner}/${git_repo}/${name}"}
fi
docker_registry=${docker_registry:-$DOCKER_REGISTRY}
docker_auth_user=${docker_auth_user:-$DOCKER_AUTH_USER}
docker_auth_secret=${docker_auth_secret:-$DOCKER_AUTH_SECRET}

if [ -z "$docker_provider" ]; then
    echo "DOCKER_PROVIDER is empty"
    exit 1
elif [ -z "$docker_registry" ]; then
    echo "DOCKER_REGISTRY is empty"
    exit 1    
elif [ -z "$docker_auth_user" ]; then
    echo "DOCKER_AUTH_USER is empty"
    exit 1
elif [ -z "$docker_auth_secret" ]; then
    echo "DOCKER_AUTH_SECRET is empty"
    exit 1    
fi

export DOCKER_REGISTRY=$docker_registry
export DOCKER_AUTH_USER=$docker_auth_user
export DOCKER_AUTH_SECRET=$docker_auth_secret
export DOCKER_ROLE=$docker_role

if [ "${DOCKER_ROLE}" == "" ]; then 
    echo "Login into ${DOCKER_REGISTRY}"
    echo "${DOCKER_AUTH_SECRET}" | $docker login -u "${DOCKER_AUTH_USER}" --password-stdin "${DOCKER_REGISTRY}"
else
    echo "TODO: fix assume role"
    exit 1
fi

docker_build_args=""
if [ "${version}" != "" ]; then
    docker_build_args+=" --build-arg=\"VERSION=${version}\""
    docker_build_args+=" --build-arg=\"APP_VERSION=${version}\""
    docker_build_args+=" --build-arg=\"IMAGE_VERSION=${version}\""
fi

# ssh
if [ $ssh -eq 1 ]; then
    if [ -e "$ssh_file" ]; then
        ssh_private_key=$(cat $ssh_file | base64)
        ssh_private_key="base64:${ssh_private_key}"
        docker_build_args+=" --build-arg=\"SSH_PRIVATE_KEY=${ssh_private_key}\""
    else
        echo "Cannot find ssh private key ($ssh_file)"
        exit 1
    fi
fi

# github
if [ $github -eq 1 ]; then    
    github_token=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_GITHUB_KEY}
    github_token=${github_token:-$GITHUB_TOKEN}    
    if [ -z $github_token ]; then
        echo "Cannot find GITHUB_TOKEN"
        exit 1
    fi
    docker_build_args+=" --build-arg=\"GITHUB_TOKEN=${github_token}\""
fi

# nuget
nuget_provider=${BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET_PROVIDER:-$BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET}
if [ $nuget != "" ] || [ "$nuget_provider" != "" ]; then
    if [ "$nuget_provider" == "github" ]; then
        nuget_baseurl=${GITHUB_PACKAGE_NUGET_BASEURL}
        nuget_auth_user=${GITHUB_PACKAGE_NUGET_USER}
        nuget_auth_secret=${GITHUB_PACKAGE_NUGET_SECRET}
    elif [ "$nuget_provider" == "jfrog" ]; then
        nuget_baseurl=${JFROG_NUGET_BASEURL}
        nuget_auth_user=${JFROG_NUGET_USER}
        nuget_auth_secret=${JFROG_NUGET_SECRET}    
    else
        nuget_baseurl=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET_URL}
        nuget_auth_user=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET_AUTH_USER}
        nuget_auth_secret=${!BUILDKITE_PLUGIN_DOCKER_IMAGE_NUGET_AUTH_SECRET}
    fi
    nuget_baseurl=${nuget_baseurl:-$NUGET_BASEURL}
    nuget_auth_user=${nuget_auth_user:-$NUGET_AUTH_USER}
    nuget_auth_secret=${nuget_auth_secret:-$NUGET_AUTH_SECRET}

    if [ "$nuget_baseurl" == "" ]; then
        echo "NUGET_BASEURL is empty"
        exit 1 
    elif [ "$nuget_auth_user" == "" ]; then
        echo "NUGET_AUTH_USER is empty"
        exit 1
    elif [ "$nuget_auth_secret" == "" ]; then
        echo "NUGET_AUTH_SECRET is empty"
        exit 1    
    fi    

    docker_build_args+=" --build-arg=\"NUGET_BASEURL=${nuget_baseurl}\""
    docker_build_args+=" --build-arg=\"NUGET_AUTH_USER=${nuget_auth_user}\""
    docker_build_args+=" --build-arg=\"NUGET_AUTH_KEY=${nuget_auth_secret}\""
fi

# build

args="--rm"
if [ $nocache -gt 0 ]; then
    args+=' --no-cache --pull'
fi

echo "$docker build ${docker_build_args} $args -f $docker_file -t $BUILDKITE_PIPELINE_SLUG:$tag_sha ." > build
chmod +x build
cat build
./build
rm build

$buildkite_agent annotate --style info "Docker image build [$BUILDKITE_PIPELINE_SLUG:$tag_sha]"

for t in $tags
do
    $docker tag $BUILDKITE_PIPELINE_SLUG:$tag_sha $docker_registry/$image:$t
    $docker push $docker_registry/$image:$t

    $buildkite_agent annotate --style info "Docker image push [$docker_registry/$image:$t]"
done

$buildkite_agent annotate --style success "Docker image push [$docker_registry/$image:$tags]"

$docker images
